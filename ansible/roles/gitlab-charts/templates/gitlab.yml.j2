gitlab:
  webservice:
    maxReplicas: "{{ gitlab_charts_webservice_max_replicas if gitlab_charts_webservice_max_replicas != '' else webservice_pods }}"
    minReplicas: "{{ gitlab_charts_webservice_min_replicas if gitlab_charts_webservice_min_replicas != '' else (webservice_pods | int * gitlab_charts_webservice_min_replicas_scaler) | int }}"
    hpa:
      targetAverageValue: 1600
    resources:
      limits:
        memory: "{{ gitlab_charts_webservice_limits_memory_gb }}G"
      requests:
        cpu: "{{ gitlab_charts_webservice_requests_cpu }}"
        memory: "{{ gitlab_charts_webservice_requests_memory_gb }}G"
    workerProcesses: "{{ gitlab_charts_webservice_requests_cpu }}"
    ingress:
      proxyBodySize: 0  # Bigger file uploads, e.g. imports
    nodeSelector:
      workload: webservice
  sidekiq:
    maxReplicas: "{{ gitlab_charts_sidekiq_max_replicas if gitlab_charts_sidekiq_max_replicas != '' else sidekiq_pods }}"
    minReplicas: "{{ gitlab_charts_sidekiq_min_replicas if gitlab_charts_sidekiq_min_replicas != '' else (sidekiq_pods | int * gitlab_charts_sidekiq_min_replicas_scaler) | int }}"
    concurrency: "{{ sidekiq_max_concurrency }}"
    hpa:
      targetAverageValue: 700m
    resources:
      limits:
        memory: "{{ gitlab_charts_sidekiq_limits_memory_gb }}G"
      requests:
        cpu: "{{ gitlab_charts_sidekiq_requests_cpu }}"
        memory: "{{ gitlab_charts_sidekiq_requests_memory_gb }}G"
    nodeSelector:
      workload: sidekiq
  task-runner:
    backups:
      objectStorage:
        {{ lookup('template', 'task_runner_backups_object_storage.' + cloud_provider + '.yml.j2') | indent(width=8) }}
  migrations:
{% if 'postgres' in groups %}
    psql:
      host: "{{ postgres_primary_int_ip }}"
      password:
        secret: gitlab-postgres-password
        key: password
      port: "{{ postgres_primary_int_port }}"
{% else %}
    enabled: false
{% endif %}

global:
  appConfig:
    object_store:
      enabled: true
      connection:
        secret: gitlab-object-storage-key
        key: key
    artifacts:
      bucket: "{{ gitlab_object_storage_artifacts_bucket }}"
    backups:
      bucket: "{{ gitlab_object_storage_backups_bucket }}"
    dependencyProxy:
      bucket: "{{ gitlab_object_storage_dependency_proxy_bucket }}"
    externalDiffs:
      bucket: "{{ gitlab_object_storage_external_diffs_bucket }}"
      when: outdated
    lfs:
      bucket: "{{ gitlab_object_storage_lfs_bucket }}"
    packages:
      bucket: "{{ gitlab_object_storage_packages_bucket }}"
    terraformState:
      bucket: "{{ gitlab_object_storage_terraform_state_bucket }}"
    uploads:
      bucket: "{{ gitlab_object_storage_uploads_bucket }}"
  initialRootPassword:
    secret: gitlab-initial-root-password
    key: password
  shell:
    authToken:
      secret: gitlab-shell-token
      key: password
  railsSecrets:
    secret: gitlab-rails-secrets
  gitaly:
{% if 'praefect' in groups %}
    authToken:
      secret: gitlab-praefect-external-token
      key: password
    enabled: false # Gitaly runs outside of cluster
    external:
    - name: default
      hostname: "{{ haproxy_internal_int_ip }}"
      port: 2305
      tlsEnabled: false
{% elif 'gitaly' in groups %}
    authToken:
      secret: gitlab-gitaly-external-token
      key: password
    enabled: false # Gitaly runs outside of cluster
    external:
    - name: default
      hostname: "{{ gitaly_primary_int_ip }}"
      port: 8075
      tlsEnabled: false
{% for gitaly_secondary_ip in gitaly_secondary_int_ips %}
    - name: "storage{{loop.index + 1}}"
      hostname: "{{ gitaly_secondary_ip }}"
      port: 8075
      tlsEnabled: false
{% endfor %}
{% endif %}
  grafana:
    enabled: true
  hosts:
{% if cloud_provider != 'aws' %}
    externalIP: "{{ external_ip }}"
{% endif %}
    domain: "{{ external_url | regex_replace('^https?:\/\/') }}"
    https: {{ external_url_ssl | lower }}
    gitlab:
      name: "{{ external_url | regex_replace('^https?:\/\/') }}"
  ingress:
{% if external_url_ssl and external_ssl_source == 'letsencrypt' %}
    configureCertmanager: true
{% elif external_url_ssl and external_ssl_source == 'user' %}
    configureCertmanager: false
    tls:
      secretName: gitlab-webservice-ssl
{% else %}
    configureCertmanager: false
    tls:
      enabled: false
{% endif %}
  minio:
    enabled: false
  psql:
    host: "{{ haproxy_internal_int_ip if 'haproxy_internal' in groups else postgres_primary_int_ip }}"
    password:
      secret: gitlab-postgres-password
      key: password
    port: "{{ 6432 if 'haproxy_internal' in groups else postgres_primary_int_port }}"
  redis:
{% if 'redis' in groups %}
{% if groups['redis'] | length == 1 %}
### Redis Single Node
    host: '{{ redis_primary_int_ip }}'
    port: '{{ redis_port }}'
    password:
      secret: gitlab-redis-password
      key: password
{% elif groups['redis'] | length > 1 %}
### Redis Multi Node
    host: gitlab-redis
    serviceName: redis
    password:
      secret: gitlab-redis-password
      key: password
    sentinels:
{% for ip in consul_int_ips %}
      - host: '{{ ip }}'
        port: '{{ redis_sentinel_port }}'
{% endfor %}
{% endif %}
{% elif 'redis_cache' in groups and 'redis_persistent' in groups %}
    cache:
      host: gitlab-redis-cache
      password:
        secret: gitlab-redis-password
        key: password
      sentinels:
{% for ip in redis_sentinel_cache_int_ips %}
      - host: '{{ ip }}'
{% endfor %}
    host: gitlab-redis-persistent
    password:
      secret: gitlab-redis-password
      key: password
    sentinels:
{% for ip in redis_sentinel_persistent_int_ips %}
      - host: '{{ ip }}'
{% endfor %}
{% endif %}

{% if external_url_ssl and external_ssl_source == 'letsencrypt' %}
certmanager:
  install: true
certmanager-issuer:
  email: "{{ external_ssl_letsencrypt_issuer_email }}"
{% else %}
certmanager:
  install: false
{% endif %}

# https://docs.gitlab.com/ee/ci/runners/#configuring-runners-in-gitlab
gitlab-runner:
  install: false

grafana:
  nodeSelector:
    workload: "support"
nginx-ingress:
  controller:
{% if aws_allocation_ids is defined %}
    service:
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-type: nlb
        service.beta.kubernetes.io/aws-load-balancer-eip-allocations: "{{ aws_allocation_ids | replace(' ', '') }}"
{% endif %}
    nodeSelector:
      workload: "support"
  defaultBackend:
    nodeSelector:
      workload: "support"

prometheus:
  alertmanager:
    nodeSelector:
      workload: "support"
  install: true
  kubeStateMetrics:
    nodeSelector:
      workload: "support"
  nodeExporter:
    nodeSelector:
      workload: "support"
  pushgateway:
    nodeSelector:
      workload: "support"
  server:
    nodeSelector:
      workload: "support"

# Run outside of cluster
redis:
  install: false
registry:
  enabled: false
postgresql:
  install: false
